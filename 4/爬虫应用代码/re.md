正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：

| 修饰符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| re.I   | 使匹配对大小写不敏感                                         |
| re.L   | 做本地化识别（locale-aware）匹配                             |
| re.M   | 多行匹配，影响 ^ 和 $                                        |
| re.S   | 使 . 匹配包括换行在内的所有字符                              |
| re.U   | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.      |
| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |

### re.S

在Python的正则表达式中，有一个参数为re.S。它表示 “.” 的作用扩展到整个字符串，包括“\n”。看如下代码：

```
`import` `re``a ``=` `'''asdfhellopass:``    ``worldaf``    ``'''``b ``=` `re.findall(``'hello(.*?)world'``,a)``c ``=` `re.findall(``'hello(.*?)world'``,a,re.S)``print` `'b is '` `, b``print` `'c is '` `, c`
```

　　

```
`运行结果：``b ``is`  `[]``c ``is`  `[``'pass:\n\t123\n\t'``]`
```

　　正则表达式中，“.”的作用是匹配除“\n”以外的任何字符，也就是说，它是在一行中进行匹配。这里的“行”是以“\n”进行区分的。a字符串有每行的末尾有一个“\n”，不过它不可见。

如果不使用re.S参数，则只在每一行内进行匹配，如果一行没有，就换下一行重新开始，不会跨行。而使用re.S参数以后，正则表达式会将这个字符串作为一个整体，将“\n”当做一个普通的字符加入到这个字符串中，在整体中进行匹配。

### re.I

　　不区分大小写

```
`res ``=` `re.findall(r``"A"``, ``"abc"``, re.I)``print``(res)`  `运行结果：[``'a'``]`
```

### re.M

　　将所有行的尾字母输出

```
`>>> s``=` `'12 34/n56 78/n90'` `>>> re.findall( r``'^/d+'` `, s , re.M )          ``# 匹配位于行首的数字` `[``'12'``, ``'56'``, ``'90'``]` `>>> re.findall( r’``/``A``/``d``+``’, s , re.M )        ``# 匹配位于字符串开头的数字` `[``'12'``]` `>>> re.findall( r``'/d+$'` `, s , re.M )          ``# 匹配位于行尾的数字` `[``'34'``, ``'78'``, ``'90'``]` `>>> re.findall( r’``/``d``+``/``Z’ , s , re.M )        ``# 匹配位于字符串尾的数字` `[``'90'``]`
```

　　

### re.sub

```
`# 要求结果：['12', '23', '34']``l ``=` `[``'1 2 '``, ``'2   3'``, ``'  3 4'``]``import` `re``print``(``eval``(re.sub(r``'\s*'``, '', ``str``(l))))`
```